#include "event_consumer.h"
#include "../logging/event_printer.h"
#include <stdlib.h>
#include <string.h>

/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c data structures.
 * */

int consume_event(struct parser_state *s, yaml_event_t *event) {
    char *value;

    char *log_level = getenv("LOG_LEVEL");
    if (log_level != NULL && strcmp(log_level, "DEBUG") == 0) {
        print_event(s->state, event->type);
    }

    switch (s->state) {
    case STATE_START:
        switch (event->type) {
        case YAML_STREAM_START_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "[STATE_START] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_STREAM:
        switch (event->type) {
        case YAML_DOCUMENT_START_EVENT:
            s->state = STATE_DOCUMENT;
            break;
        case YAML_STREAM_END_EVENT:
            s->state = STATE_STOP; /* All done. */
            break;
        default:
            fprintf(stderr, "[STATE_STREAM] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_DOCUMENT:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_SECTION;
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr,
                    "[STATE_DOCUMENT] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SECTION:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "task") == 0) {
                s->state = STATE_TLIST;
            } else {
                fprintf(stderr, "[STATE_SECTION] Unexpected scalar: %s\n",
                        value);
                return FAILURE;
            }
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_STOP;
            break;
        default:
            fprintf(stderr,
                    "[STATE_SECTION] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_TLIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_TVALUES;
            break;
        case YAML_MAPPING_END_EVENT:
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "[STATE_TLIST] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_TVALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_TKEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_TLIST;
            break;
        default:
            fprintf(stderr,
                    "[STATE_TVALUES] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_TKEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "name") == 0) {
                s->state = STATE_TNAME;
            } else if (strcmp(value, "step") == 0) {
                s->state = STATE_SLIST;
            } else {
                fprintf(stderr, "[STATE_TKEY] Unexpected key: %s\n", value);
                return FAILURE;
            }
            break;
        case YAML_MAPPING_END_EVENT:
            add_task(&s->tlist, s->t.name, s->slist);
            free(s->t.name);
            memset(&s->t, 0, sizeof(s->t));
            s->slist = NULL;
            s->state = STATE_TVALUES;
            break;
        default:
            fprintf(stderr, "[STATE_TKEY] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_TNAME:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->t.name) {
                fprintf(stderr,
                        "[STATE_TNAME] Warning: duplicate 'name' key.\n");
                free(s->t.name);
            }
            s->t.name = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_TKEY;
            break;
        default:
            fprintf(stderr, "[STATE_TNAME] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SLIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_SVALUES;
            break;
        default:
            fprintf(stderr, "[STATE_SLIST] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SVALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_SKEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_TKEY;
            break;
        default:
            fprintf(stderr,
                    "[STATE_SVALUES] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SKEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "name") == 0) {
                s->state = STATE_SNAME;
            } else if (strcmp(value, "run") == 0) {
                s->state = STATE_SCOMMAND;
            } else {
                fprintf(stderr, "[STATE_SKEY] Unexpected key: %s\n", value);
                return FAILURE;
            }
            break;
        case YAML_MAPPING_END_EVENT:
            add_step(&s->slist, s->s.name, s->clist);
            free(s->s.name);
            memset(&s->s, 0, sizeof(s->s));
            s->clist = NULL;
            s->state = STATE_SVALUES;
            break;
        default:
            fprintf(stderr, "[STATE_SKEY] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SNAME:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->s.name) {
                fprintf(stderr,
                        "[STATE_SNAME] Warning: duplicate 'name' key.\n");
                free(s->s.name);
            }
            s->s.name = bail_strdup((char *)event->data.scalar.value);
            s->state = STATE_SKEY;
            break;
        default:
            fprintf(stderr, "[STATE_SNAME] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SCOMMAND:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_SCOMMAND_VALUES;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_SKEY;
            break;
        default:
            fprintf(stderr,
                    "[STATE_SCOMMAND] Unexpected event %d in state %d.\n",
                    event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SCOMMAND_VALUES:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            if (s->c.exec) {
                fprintf(stderr,
                        "[STATE_SNAME] Warning: duplicate 'name' key.\n");
                free(s->c.exec);
            }
            s->c.exec = bail_strdup((char *)event->data.scalar.value);
            add_command(&s->clist, s->c.exec);
            free(s->c.exec);
            memset(&s->c, 0, sizeof(s->c));
            s->state = STATE_SCOMMAND_VALUES;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_SKEY;
            break;
        default:
            fprintf(
                stderr,
                "[STATE_SCOMMAND_VALUES] Unexpected event %d in state %d.\n",
                event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_STOP:
        break;
    }

    return SUCCESS;
}
